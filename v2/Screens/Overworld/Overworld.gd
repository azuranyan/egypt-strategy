extends Control

# events generated by the players actions
const click_on_territory := 'overworld.click_on_territory'
const click_on_map := 'overworld.click_on_map'
const right_click := 'overworld.right_click'
const click_on_inspect := 'overworld.click_on_inspect'
const rest := 'overworld.rest'
const invade := 'overworld.invade'
const turn_end := 'overworld.turn_end'
# events generated by the game
const win_territory := 'overworld.win_territory'
const all_territories_taken := 'overworld.all_territories_taken'

var manager: Manager
var battle_manager: BattleManager

	
# Called when the node enters the scene tree for the first time.
func _ready():
	if Engine.is_editor_hint():
		print("[editor] ready: overworld")
	else:
		print("ready: overworld")
		
	# TODO parent._ready is what initializes the global variables, so having
	# stuff set here means that parent._ready hasnt ran yet and we'd have
	# nothing, that's why we wait for it to be ready. this is ugly and should
	# be changed later to a better loading sequence
	await get_parent().ready
		
	register_territories_to_globals()
	
	register_empires_to_globals()
		
	for e in Globals.territories.values():
		var territory: String = e.name
		var leader: String = e.empire.leader.name
		var player_controlled: bool = e.empire.leader.get_meta("player", false)
		print("Territory: <%s>; Leader: <%s>; PlayerControlled: <%s>" %
			[territory, leader, player_controlled])
	
	# create turn cycle main loop
	manager = Manager.new()
	call_deferred("_start_overworld_cycle")
	
	# create battle manager
	battle_manager = MockBattleManager.new()
	
	# connect overworld events
	OverworldEvents.connect("empire_attack", _empire_attack)
	#OverworldEvents.connect("empire_attack", battle_manager.initiate_attack)
	OverworldEvents.connect("all_territories_taken", spawn_boss)
	OverworldEvents.connect("battle_result", _battle_result)
	
	# connect cycle events
	OverworldEvents.connect("cycle_turn_start", _turn_start)


func _start_overworld_cycle():
	manager.do_cycle()

	
func _turn_start(empire: Empire):
	if empire.is_player_owned():
		# no need to do anything, just wait for cycle_turn_end from the ui
		pass
	else:
		$MouseEventBlocker.show()
		await get_tree().create_timer(1.0).timeout
		_do_ai_turn(empire)
		$MouseEventBlocker.hide()
		_end_turn()
		
		# this has to be deferred if we're calling in the same frame otherwise
		# we'd be firing the signal at the same time as the main loop is
		# awaiting and it wouldn't work
		# call_deferred("_end_turn")
		

func _end_turn():
	OverworldEvents.emit_signal("cycle_turn_end", manager.turn_order[manager.current_turn])

	
func _do_ai_turn(empire: Empire):
	if empire.hp_multiplier < 0.8:
		empire_rest(empire)
	else:
		empire.aggression += randf()
		
		if empire.aggression < 1.0:
			empire.aggression += 0.05
			empire_rest(empire)
		else:
			var adjacent: Array[Territory] = empire.get_adjacent()
			print("[%s] %s (%s); %s" % [manager.current_turn, empire.leader.name, manager.get_empire_turn_order(empire), adjacent])
			
			if adjacent.size() > 0:
				var target_territory: Territory = adjacent[randi() % adjacent.size()]
				
				_empire_attack(empire, target_territory)
				empire.aggression = empire.base_aggression
			else:
				# degenerate case of not having neighbors
				print("warning: possible logic error: %s has no neighbors" % empire.leader.name)
			

func empire_rest(empire: Empire):
	if empire.is_player_owned():
		print("%s rests. HP recovered." % empire.leader.name)
	else:
		print("%s rests. HP recovered (aggression: %s)" % [empire.leader.name, empire.aggression])
		
	empire.hp_multiplier = 1.0
	
	
# TODO put into battle manager or something
func _empire_attack(empire: Empire, territory: Territory):
	print("%s attacks %s (%s)!" % [empire.leader.name, territory.name, territory.empire.leader.name])
	battle_manager.initiate_attack(empire, territory)


func _attacker_victory(empire: Empire, territory: Territory):
	print("territory taken!")
	var old_owner := territory.empire
	
	# change owners
	territory_set_owner(territory, empire)
	
	# if home_territory, give the rest to the winning empire
	if Globals.prefs['defeat_if_home_territory_captured'] and territory == old_owner.home_territory:
		print("    home territory is captured!")
		while !old_owner.territories.is_empty():
			var t: Territory = old_owner.territories.pop_back()
			print("        surrendering %s" % t.name)
			territory_set_owner(t, empire)
			
	# remove from the pool if needed
	if old_owner.is_beaten():
		print("%s is defeated!" % old_owner.leader.name)
		
		if old_owner.is_player_owned():
			print("player defeated, game uber")
		else:
			if old_owner.leader.get_meta("final_boss", false):
				# boss
				print("boss defeated, congerets")
				OverworldEvents.emit_signal("boss_defeated")
			else:
				# normal enemy
				update_boss_spawn_condition()
			manager.remove_from_turn_order(old_owner)
			
			
func _battle_result(empire: Empire, territory: Territory, result: BattleManager.Result):
	var attacker := empire
	var defender := territory.empire
	#print("YE? AM STUPID THIS WOT I GOT ", result)
	match result:
		BattleManager.Result.AttackerVictory:
			_attacker_victory(empire, territory)
			defender.hp_multiplier = 0.1
		BattleManager.Result.DefenderWithdraw:
			_attacker_victory(empire, territory)
		BattleManager.Result.AttackerWithdraw:
			print("withdraw! battle lost!")
		BattleManager.Result.DefenderVictory:
			print("battle lost!")
			attacker.hp_multiplier = 0.1


func update_boss_spawn_condition():
	for t in Globals.territories.values():
		if t.get_leader() != Globals.chara["Sitri"] and !t.is_player_owned():
			return
	
	OverworldEvents.emit_signal("all_territories_taken")
	
		
func spawn_boss():
	# await boss spawn animation
	
	connect_territories(Globals.territories["Cursed Stronghold"], Globals.territories["Ruins of Atesh"])
	
	manager.turn_order.append(Globals.empires["Sitri"])
	

## Connects two territories together
func connect_territories(a: Territory, b: Territory):
	if b not in a.adjacent:
		a.adjacent.append(b)
	if a not in b.adjacent:
		b.adjacent.append(a)


## Adds the territories to the global registry.
func register_territories_to_globals():
	Globals.territories.clear()
	for c in get_children():
		if c is TerritoryButton:
			Globals.territories[c.territory.name] = c.territory
			

## Assign territories and adds the empires to the global registry
func register_empires_to_globals():
	Globals.empires.clear()
	
	_register_new_empire(Globals.chara["Lysandra"], Globals.territories["Zetennu"])
	_register_new_empire(Globals.chara["Sitri"], Globals.territories["Cursed Stronghold"])
	
	var selection: Array[Chara] = []
	for c in Globals.chara.values():
		if c.get_meta("territory_selection", false):
			selection.append(c)
			
	selection.shuffle()
	# var i := 0
	for t in Globals.territories.values():
		if t.empire == null:
			# t.empire = _register_new_empire(selection[i], t)
			# i = (i + 1) % selection.size()
			assert(not selection.is_empty(), 'not enough charas for territories')
			t.empire = _register_new_empire(selection.pop_back(), t)


func _register_new_empire(leader: Chara, home_territory: Territory) -> Empire:
	var empire := Empire.new()
	empire.leader = leader
	empire_give_territory(null, empire, home_territory, true)
	Globals.empires[leader.name] = empire
	return empire
	
	
# api functions?
func empire_give_territory(from_empire: Empire, to_empire: Empire, territory: Territory, home_territory: bool=false):
	# take
	if from_empire != null:
		from_empire.territories.erase(territory)
		for unit in territory.units:
			from_empire.units.erase(unit)
	
	assert(to_empire != null, "to_empire is null")
	
	# give
	to_empire.territories.append(territory)
	to_empire.units.append_array(territory.units)
	
	# assign home if needed
	if home_territory:
		assert(to_empire.home_territory == null, "home_territory set multiple times")
		to_empire.home_territory = territory
		
	# change owner
	territory.empire = to_empire
	
	# broadcast
	OverworldEvents.territory_owner_changed.emit(from_empire, to_empire, territory)
	

func territory_set_owner(territory: Territory, new_empire: Empire):
	var old_empire: Empire = territory.empire
	empire_give_territory(old_empire, new_empire, territory)
	

